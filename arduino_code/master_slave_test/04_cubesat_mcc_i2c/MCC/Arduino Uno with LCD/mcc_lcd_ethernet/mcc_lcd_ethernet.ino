// Government Agency Original Software Designation: LAR-18832-1
//
//------------------------------------------------------------------------------
// NASA/GSFC, Software Integration & Visualization Office, Code 610.3
//------------------------------------------------------------------------------
//
// MODULES: LCD 2x16, 433 mHz antennas & Ethernet Shield.
//
//> @author
//> Albert AarÃ³n Cervera Uribe
//
// DESCRIPTION:
//> This script contains a testing version of MCC as controller with an
//  Ethernet Shield that serves the received data to a local host server.
//
// Notation:
// MCC_A: MCC controller (master) Arduino.
//
//
// NOTES & WARNINGS
// MCC_A and MCC_B are connected the following way:
// 1) SDA --> SDA
// 2) SCL --> SCL
// 3) MCC_A's 5v -> MCC_B's Vin
// 4) MCC_A's GND -> MCC_B's GND
//
// ISSUE:
// 1) Program storage space should not pass 80% or it won't execute properly.
// 2) Energy received into MCC_B's Vin from MCC_A's 5v may not be enough to
//    power external loads (instruments).
//
// REVISION HISTORY:
// 23 March 2023 - Initial Version
//  March 2023 - Modification
// -- -- 2023 - Final first Version
//
// TODO_dd_mmm_yyyy - TODO_describe_appropriate_changes - TODO_name
//------------------------------------------------------------------------------

#include <LiquidCrystal.h>
#include <Keypad.h>
#include <RH_ASK.h>  // Include RadioHead Amplitude Shift Keying Library
#include <Wire.h>
#include <SPI.h>
#include <Ethernet.h>

// Create Amplitude Shift Keying Object (Receive on PIN 7 and send on PIN 6)
RH_ASK rf_driver(2000, 7, 6, 0);  // Params: speed in BPS, rxPin, txPin, pttPin

// LCD configuration
#define RS 8  // 12
#define EN 9  // 13
#define D4 5
#define D5 6  //4
#define D6 3
#define D7 2

unsigned long lastDataReceived;  // miliseconds with no signal from transmitter
unsigned long currentMillis;     // current miliseconds var to compare data
uint32_t losTolerance = 630000;  // Loss of Signal tolerance in ms //630 sec = 10 min, 30 sec

char key;
char lastKey;
char option;
float heatIndex;
int dataMode = 1;

// 28 bytes size and 7 elements (4 bytes each(?))
struct telemetryStruct {
  float humidity;
  float temperature;
  float pressure;
  float localAltitude;  // altitude in meters from ground
  float pitch;
  float roll;
  float yaw;
} telemetryData;

// 6 bytes size and 2 elements (3 bytes each(?))
struct dataStruct {
  int mode;
  float voltage;
  float internalTemp;  // dedicated temperature DSB18B20 sensor
  // float solarCurrent; // Future val: current generated by solar arrays
} systemData;

struct transferStruct {
  // System data:
  int mode;
  float voltage;
  float internalTemp;
  bool clockSynced;
  int bootDay;
  int bootMonth;
  int bootYear;
  int bootHour;
  int bootMinute;
  int bootSecond;
  // Science payload data:
  float humidity;
  float temperature;
  float pressure;
  float localAltitude;  // altitude in meters from ground (not MSL)
  float pitch;
  float roll;
  float yaw;
} transferData;

struct commandStruct {
  float op;
} commandData;

int initDay, initMonth, initYear, initHour, initMinute, initSecond;

byte tx_buf[sizeof(commandData)] = { 0 };  // buffer for sending command data

// INITIALIZATION OF COMPONENTS
LiquidCrystal lcd(RS, EN, D4, D5, D6, D7);

/*
  Ethernet shield attached to pins 10, 11, 12, 13 and 4 to ISC  
*/
// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192, 168, 1, 177);

// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(8080);

void setup() {
  // Setup Serial Monitor
  Serial.begin(9600);

  lcd.begin(16, 2);
  lcd.setCursor(0, 0);
  lcd.print("NASA - CubeSat 1");
  lcd.setCursor(0, 1);  //
  lcd.print("Mission Control");

  delay(1850);
  lcd.clear();
  systemData.mode = -1;  // To differentiate actual '0 mode' vs no data received.
  lastDataReceived = 0;
  key = 'D';      // A
  lastKey = 'D';  // A

  // Initialize ASK Object
  rf_driver.init();
  Wire.begin();  // join i2c bus (address optional for master)

  // Start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);

  /*
    M1: Ethernet shield was not found.  Sorry, can't run without hardware. :(
    M2: Ethernet cable is not connected.
    M3: server is at 
  */

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println("M1");
    while (true) {
      delay(1);  // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println("M2");
  }

  // start the server
  server.begin();
  // Serial.print("M3 ");
  // Serial.println(Ethernet.localIP());
}

void loop() {





  // Receiver antenna code -----------------------------
  // Set buffer to size of expected message
  // int8_t buf[RH_ASK_MAX_MESSAGE_LEN];  // Set it to maximum size of 60 bytes, but not the actual expected size
  int8_t buf[sizeof(transferData)];
  uint8_t buflen = sizeof(buf);

  // Non-blocking
  if (rf_driver.recv(buf, &buflen)) {  // rf_driver.recv(buf, &buflen) == 1
    // If data received ...

    lastDataReceived = millis();
    memcpy(&transferData, buf, sizeof(transferData));

    initDay = transferData.bootDay;
    initMonth = transferData.bootMonth;
    initYear = transferData.bootYear;
    initHour = transferData.bootHour;
    initMinute = transferData.bootMinute;
    initSecond = transferData.bootSecond;

    // Workaround for sending these data through I2C for SD storage
    systemData.mode = transferData.mode;
    systemData.voltage = transferData.voltage;
    systemData.internalTemp = transferData.internalTemp;
    telemetryData.humidity = transferData.humidity;
    telemetryData.temperature = transferData.temperature;
    telemetryData.pressure = transferData.pressure;
    telemetryData.localAltitude = transferData.localAltitude;
    telemetryData.pitch = transferData.pitch;
    telemetryData.roll = transferData.roll;
    telemetryData.yaw = transferData.yaw;


    // sendDataI2C(); // Send telemetryData via I2C to peripheral slave
    // setUI(key);


  } else if ((rf_driver.recv(buf, &buflen) == 0)) {
    /*
    TODO: When no signal is received from Delta1, display in some screen
    how many seconds have happened since LOS (Loss of Signal).
    */
    // setUI(key);
    currentMillis = millis();
    // If in 10 mins, 30 secs no data is received, display message
    if (currentMillis - lastDataReceived >= losTolerance) {
      Serial.print("\nNo data\n");
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("[!!!] No data");
      lcd.setCursor(0, 1);
      lcd.print("from CubeSat");
    }
  }

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("CubeSat Mode: ");
  lcd.setCursor(14, 0);
  lcd.print(systemData.mode);
  lcd.setCursor(0, 1);
  lcd.print("Temp: ");
  lcd.setCursor(6, 1);
  lcd.print(systemData.internalTemp);
  lcd.setCursor(12, 1);
  lcd.print((char)223);
  lcd.setCursor(13, 1);
  lcd.print("C");
  webServer();

  delay(250);
}  // end void loop

void webServer() {
  heatIndex = computeHeatIndex(telemetryData.temperature, telemetryData.humidity);

  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    // Serial.println("new client");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\n' && currentLineIsBlank) {

          client.println("HTTP/1.1 200 OK");  //send new page
          client.println("Content-Type: text/html");
          // client.println("Refresh: 5");
          client.println();
          client.println("<HTML>");
          client.println("<HEAD>");
          client.println("<meta name='apple-mobile-web-app-capable' content='yes' />");
          client.println("<meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />");
          client.println("<link rel='stylesheet' type='text/css' href='https://randomnerdtutorials.com/ethernetcss.css' />");
          client.println("<TITLE>Delta-1</TITLE>"); // MCC Delta-1
          client.println("</HEAD>");
          // client.println("<BODY>");
          client.println("<body style='background-color:powderblue;'>");


          client.println("<H1>MCC || Delta-1</H1>");
          client.println("<hr />");
          // client.println("<br />");
          client.println("<H2>Payload Data</H2>");
          // CubeSat Delta-1
          // client.println("<br />");

          client.print("<h3>Temperature: </h3>");
          client.print(telemetryData.temperature);
          client.print(" &#176C");

          client.print("<h3>Humidity: </h3>");
          client.print(telemetryData.humidity);
          client.print(" %");

          client.print("<h3>Heat Index: </h3>");
          client.print(heatIndex);
          client.print(" &#176C");

          client.print("<h3>Barometer: </h3>");
          client.print(telemetryData.pressure);
          client.print(" hPa");

          client.print("<h3>Local Altitude: </h3>");
          client.print(telemetryData.localAltitude);
          client.print(" m");

          client.print("<h3>X: </h3>");
          client.print(telemetryData.pitch);
          client.print(" &#176");

          client.print("<h3>Y: </h3>");
          client.print(telemetryData.roll);
          client.print(" &#176");

          // client.print("<h3>Z: </h3>");
          // client.print(telemetryData.yaw);
          // client.print(" &#176");

          // client.println("<br />");
          client.println("<hr />");
          client.println("<H2>Health data</H2>");
          // client.println("<br />");

          client.print("<h3>CubeSat Mode: </h3>");
          client.print(systemData.mode);

          // client.print("<h3>Spacecraft Boot Time: </h3>");
          // // String bootTime = String(initDay);
          // client.print(initDay);

          // String dateLabel = String(initMonth) + String(initDay) + ", " + String(initYear);

          // client.print(String(initMonth) + ", " + String(initDay) + ", " + String(initYear));

          client.print("<h3>Internal temperature: </h3>");
          client.print(systemData.internalTemp);
          client.print(" &#176");

          client.print("<h3>RTC Synced: </h3>");
          client.print(transferData.clockSynced);

          client.println("<hr />");
          // client.println("<br />");
          client.println("<p>Albert Cervera, 2023</p>");
          // client.println("<br />");
          client.println("</BODY>");
          client.println("</HTML>");


          break;
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    // Serial.println("client disconnected");
  }
}

// void setUI(char key) {
//   switch (key) {
//     case 'A':
//       // Show temp and hum info
//       lastKey = 'A';
//       Serial.print("\nShow temperature");
//       // Serial.print("RECEIVED DATA: ");
//       // Serial.print("humidity: ");
//       // Serial.print(telemetryData.humidity);
//       // Serial.print("  temperature: ");
//       // Serial.print(telemetryData.temperature);
//       // Serial.print('\n');
//       lcd.clear();
//       lcd.setCursor(0, 0);
//       lcd.print("Hum: ");
//       lcd.setCursor(5, 0);
//       lcd.print(telemetryData.humidity);
//       lcd.setCursor(11, 0);
//       lcd.print("%");

//       lcd.setCursor(0, 1);
//       lcd.print("Temp: ");
//       lcd.setCursor(6, 1);
//       lcd.print(telemetryData.temperature);
//       lcd.setCursor(12, 1);
//       lcd.print((char)223);
//       lcd.setCursor(13, 1);
//       lcd.print("C");

//       break;
//     case 'B':
//       // Show barometer info
//       lastKey = 'B';
//       Serial.print("\nShow pressure");

//       lcd.clear();
//       lcd.setCursor(0, 0);
//       lcd.print("Barometer: ");
//       lcd.setCursor(0, 1);
//       lcd.print(telemetryData.pressure);
//       lcd.setCursor(7, 1);
//       lcd.print("hPa");

//       break;
//     case 'C':
//       lastKey = 'C';
//       // Serial.print("\nC was pressed");
//       // Serial.print("\nShow IMU telemetry");

//       // lcd.clear();
//       // lcd.setCursor(0, 0);
//       // lcd.print("Pitch, Roll, Yaw");
//       // delay(1000);

//       lcd.clear();
//       lcd.setCursor(0, 0);
//       lcd.print("X:");
//       lcd.setCursor(2, 0);
//       lcd.print(telemetryData.pitch);
//       lcd.setCursor(8, 0);
//       lcd.print((char)223);

//       lcd.setCursor(10, 0);
//       lcd.print("Y:");
//       lcd.setCursor(0, 1);
//       lcd.print(telemetryData.roll);
//       lcd.setCursor(6, 1);
//       lcd.print((char)223);

//       lcd.setCursor(7, 1);
//       lcd.print("Z:");
//       lcd.setCursor(9, 1);
//       lcd.print(telemetryData.yaw);
//       lcd.setCursor(15, 1);
//       lcd.print((char)223);

//       break;
//     case 'D':
//       lastKey = 'D';
//       // Serial.print("\nD was pressed");

//       // // Wire.requestFrom(8, 6);  // request 6 bytes from peripheral device #8
//       // Wire.requestFrom(8, 8); // sizeof rtcData, 16, 8 for time and 8 for date
//       // Wire.readBytes((byte*)&rtcData, sizeof rtcData);

//       // Serial.print("\nTime: ");
//       // Serial.print(rtcData.time);

//       // // Ensures reading of all bytes from stream
//       // while (Wire.available()) {
//       //   Wire.read();
//       // }


//       // lcd.clear();
//       // lcd.setCursor(0, 0);
//       // lcd.print("D) Invalid Op.");
//       //lcd.print(rtcData.time);

//       lcd.clear();
//       lcd.setCursor(0, 0);
//       lcd.print("CubeSat Mode: ");
//       lcd.setCursor(14, 0);
//       lcd.print(systemData.mode);
//       lcd.setCursor(0, 1);
//       lcd.print("Temp: ");
//       lcd.setCursor(6, 1);
//       lcd.print(systemData.internalTemp);
//       lcd.setCursor(12, 1);
//       lcd.print((char)223);
//       lcd.setCursor(13, 1);
//       lcd.print("C");

//       // lcd.print("Voltage: ");
//       // lcd.setCursor(9, 1);
//       // lcd.print(systemData.voltage);
//       // lcd.setCursor(14, 1);
//       // lcd.print("V");

//       break;
//     case '*':
//       switch (lastKey) {
//         case 'A':
//           // A*: Compute and show heat index
//           Serial.print("\nA *");
//           Serial.print("\nShow heat index");

//           heatIndex = computeHeatIndex(telemetryData.temperature, telemetryData.humidity);
//           // heatIndex = computeHeatIndex(35.00, 86.00); //61 c
//           // test 80 and 112 F = 26.6 and 44.4 C and hum <13% => condition 1
//           // 26 and 30 c and R>85 => condition 2

//           lcd.clear();
//           lcd.setCursor(0, 0);
//           lcd.print("Heat Index: ");
//           lcd.setCursor(0, 1);
//           lcd.print(heatIndex);
//           lcd.setCursor(7, 1);
//           lcd.print((char)223);
//           lcd.setCursor(8, 1);
//           lcd.print("C");

//           break;
//         case 'B':
//           // B*: Show local altitude
//           Serial.print("\nB *");
//           Serial.print("\nShow local altitude");

//           lcd.clear();
//           lcd.setCursor(0, 0);
//           lcd.print("CubeSat Height: ");
//           lcd.setCursor(0, 1);
//           lcd.print(telemetryData.localAltitude);
//           lcd.setCursor(7, 1);
//           lcd.print("m");

//           break;
//         case 'C':
//           Serial.print("\nC *");
//           break;
//         case 'D':
//           Serial.print("\nD *");
//           // Turn ON ESM mode on Delta_1

//           lcd.clear();
//           lcd.setCursor(0, 0);
//           lcd.print("Sending TX for");
//           lcd.setCursor(0, 1);
//           lcd.print("ESM ON ...");

//           // Transmit command 3 seconds
//           sendCommand(1.0, 3);  // activate ESM

//           lcd.clear();
//           lcd.setCursor(0, 0);
//           lcd.print("[OK] ESM");
//           lcd.setCursor(0, 1);
//           lcd.print("Requested");
//           delay(1500);

//           lastKey = 'D';
//           key = 'D';

//           break;
//           // case '*':
//           //   lastKey = 'A'; // Return to previous mode
//           //   break;
//       }
//       break;
//     case '#':
//       if (lastKey == 'B') {
//         Serial.print("\nB#");
//         Serial.print("\nReset barometer");

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("Sending TX for");
//         lcd.setCursor(0, 1);
//         lcd.print("Alt. Reset ...");

//         // Send command

//         if (systemData.mode == 0 || systemData.mode == 1) {
//           sendCommandAndListen(2.0, 660, true);  // Transmit 11 mins to reset local altitude on Delta1
//         } else {
//           sendCommand(2.0, 3);  // ask for reset pressureGroundLevel
//         }

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("[OK] Alt. Reset");
//         lcd.setCursor(0, 1);
//         lcd.print("Requested");
//         delay(1500);

//         lastKey = 'B';
//         key = '*';
//         break;
//       } else if (lastKey == 'C') {
//         Serial.print("\nC#");
//         Serial.print("\nAsk for IMU data");

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("Sending TX for");
//         lcd.setCursor(0, 1);
//         lcd.print("RTI Mode ...");

//         // Send command
//         sendCommand(4.0, 3);  // Activate RTI mode

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("[OK] RTI ");
//         lcd.setCursor(0, 1);
//         lcd.print("Requested");
//         delay(1500);

//         /* Problem: infinite loop on key '#' option
//         If I set lastKey = B, and key = B, the bug goes to instruction B#

//         It seems that after the setUI(key) call, even though key is reassigned, it
//         is immediately converted to '#', hence the infinite loop on 'C#'

//         NOTE: this seems to be the expected behaviour, where if an option is chosen,
//         let say '*', after each void loop(), the same option is triggered and showed
//         on the LCD.
//         */

//         lastKey = 'C';
//         key = 'C';

//         // Serial.print("\nNew lastKey: ");
//         // Serial.print(lastKey);
//         // Serial.print("\nNew key: ");
//         // Serial.print(key);
//         // delay(1000);


//         break;
//         Serial.print("\nAfter break");
//       } else if (lastKey == 'A') {
//         Serial.print("\nA#");
//         Serial.print("\nAsk for weather and IMU data");

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("Sending TX for");
//         lcd.setCursor(0, 1);
//         lcd.print("RTWI Mode ...");

//         // Send command
//         sendCommand(5.0, 3);  // Activate RTWI mode

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("[OK] RTWI ");
//         lcd.setCursor(0, 1);
//         lcd.print("Requested");
//         delay(1500);

//         lastKey = 'A';
//         key = 'A';
//         break;
//       } else if (lastKey == 'D') {
//         Serial.print("\nD#");

//         // Turn OFF ESM mode on Delta1
//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("Sending TX for");
//         lcd.setCursor(0, 1);
//         lcd.print("ESM OFF ...");

//         // Transmit command  for 11 minutes, but listen in between for incomming transmission.
//         sendCommandAndListen(5.0, 660, false);  // Transmit 11 mins to activate RTWI mode on Delta1, false for altitude reset

//         lcd.clear();
//         lcd.setCursor(0, 0);
//         lcd.print("[OK] RTWI");
//         lcd.setCursor(0, 1);
//         lcd.print("Requested");
//         delay(1500);

//         lastKey = 'D';
//         key = 'D';

//         break;

//       } else {
//         key = lastKey;  // Return to previous mode
//       }
//       break;
//   }  // end switch()
//   // Serial.print("\nEnd of switch");
//   // Serial.print("\nkey:");
//   // Serial.print(key);

// }  // end setUI()

void sendCommandAndListen(float command, int seconds, bool altitudReset) {
  /*
  Description: it loops a defined amount of time (seconds) while 
  transmitting and receiving in equal periods. For example, for 11 minutes
  transmit 2 seconds, then listen 2 seconds, transmit again, listen again, etc...
  */

  uint32_t msTransmit = (seconds * 1000UL);  // To avoid integer overflow with 16 bit math
  commandData.op = command;
  memcpy(tx_buf, &commandData, sizeof(commandData));
  byte zize = sizeof(commandData);

  // consider declaring transferData as global variable
  struct transferStruct {
    int mode;
    float voltage;
    float internalTemp;
    bool clockSynced;
    float humidity;
    float temperature;
    float pressure;
    float localAltitude;  // altitude in meters from ground
    float pitch;
    float roll;
    float yaw;
  } transferData;

  bool rcvd = false;
  int8_t buf[RH_ASK_MAX_MESSAGE_LEN];  // Set it to maximum size of 60 bytes
  uint8_t buflen = sizeof(buf);
  unsigned long startTime2;
  unsigned long endTime2;
  unsigned long startTime = millis();
  unsigned long endTime = startTime;

  Serial.print("\nTransmitting 11 mins, with msTransmit: ");
  Serial.print(msTransmit);

  // Transmit command X seconds
  while ((endTime - startTime) <= msTransmit) {  // msTransmit should be equal to 11 mins in ms
    // Do transmit and listen events in periods of 2 seconds:

    Serial.print("\nTransmitting 2 seconds ...");
    startTime2 = millis();
    endTime2 = startTime2;
    while ((endTime2 - startTime2) <= 2000) {  // transmit 2 seconds
      rf_driver.send((uint8_t *)tx_buf, zize);
      rf_driver.waitPacketSent();
      endTime2 = millis();
    }

    Serial.print("\nListening 2 seconds ...");
    startTime2 = millis();
    endTime2 = startTime2;
    while ((endTime2 - startTime2) <= 2000) {  // listen 2 seconds for ack from Spacecraft
      if (rf_driver.recv(buf, &buflen) == 1) {

        Serial.print("\nAck received from spacecraft");

        lastDataReceived = millis();
        memcpy(&transferData, buf, sizeof(transferData));

        systemData.mode = transferData.mode;
        systemData.voltage = transferData.voltage;
        systemData.internalTemp = transferData.internalTemp;
        telemetryData.humidity = transferData.humidity;
        telemetryData.temperature = transferData.temperature;
        telemetryData.pressure = transferData.pressure;
        telemetryData.localAltitude = transferData.localAltitude;
        telemetryData.pitch = transferData.pitch;
        telemetryData.roll = transferData.roll;
        telemetryData.yaw = transferData.yaw;

        if (altitudReset) {
          if (telemetryData.localAltitude >= -0.6 && telemetryData.localAltitude <= 0.6) {
            rcvd = true;
            break;  // leave this while loop
          }
        } else {
          // Only if another spacecraft mode different from ESM is received
          if (systemData.mode != 1) {
            rcvd = true;
            break;  // leave this while loop
          }
        }

      }  // end if received
      endTime2 = millis();
    }

    if (rcvd) {
      Serial.print("\nrcvd is true, leaving transmission ...");
      break;  // leave the whole 11 mins while iteration
    }

    endTime = millis();
  }  // end while 11 mins
  Serial.print("\nDone with transmission");
}

void sendCommand(float command, int seconds) {
  int msTransmit = seconds * 1000;
  commandData.op = command;
  memcpy(tx_buf, &commandData, sizeof(commandData));
  byte zize = sizeof(commandData);

  // Transmit command X seconds
  unsigned long startTime = millis();
  unsigned long endTime = startTime;
  while ((endTime - startTime) <= msTransmit) {
    rf_driver.send((uint8_t *)tx_buf, zize);
    rf_driver.waitPacketSent();
    endTime = millis();
  }
  Serial.print("\nData command was sent");
}

float computeHeatIndex(float temp, float hum) {
  float T = (temp * 1.8) + 32;  // temp in Farenheit
  float R = hum;
  float HI = 0.5 * (T + 61.0 + ((T - 68.0) * 1.2) + (R * 0.094));
  // Average simple HI with T, if greater than 80F use complex Rothfusz equation
  if ((HI + T) / 2.0 > 80) {
    HI = heatIndexFullEquation(T, R);
  }
  heatIndex = (HI - 32) * (5.0 / 9.0);
  return heatIndex;
}

float heatIndexFullEquation(float T, float R) {
  float adjus;
  float c1 = -42.379;
  float c2 = 2.04901523;
  float c3 = 10.14333127;
  float c4 = -0.22475541;
  float c5 = -6.83783 * (pow(10, -3));  //x10-3
  float c6 = -5.481717 * (pow(10, -2));
  float c7 = 1.22874 * (pow(10, -3));
  float c8 = 8.5282 * (pow(10, -4));
  float c9 = -1.99 * (pow(10, -6));

  float HI = (c1 + (c2 * T) + (c3 * R) + (c4 * T * R) + (c5 * (T * T)) + (c6 * (R * R)) + (c7 * (T * T) * R) + (c8 * T * (R * R)) + (c9 * (T * T) * (R * R)));

  if (T >= 80.0 && T <= 112.0 && R < 13.0) {
    adjus = ((13.0 - R) / 4.0) * sqrt((17.0 - abs(T - 95.0)) / 17.0);
    HI = HI - adjus;
  } else if (T >= 80.0 && T <= 87.0 && R > 85.0) {
    adjus = ((R - 85.0) / 10.0) * ((87.0 - T) / 5.0);
    HI = HI + adjus;
  }

  return HI;
}

// void sendDataI2C() {
//   /*
//   WARNING: by default you can only send 32 bytes of data with the Wire.h library.
//   I change it via 'nano' command to 64 bytes
//   UPDATE: Arduino UNO buffer is only 32 bytes
//   */
//   // Serial.print("\nSending telemetryData to peripheral ...\n");
//   Wire.beginTransmission(8);  // transmit to device #8

//   // Send struct data via I2C
//   Wire.write((byte *)&telemetryData, sizeof telemetryData);
//   Wire.endTransmission();  // stop transmitting
// }
